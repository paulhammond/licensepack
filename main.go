package main

import (
	"bytes"
	"embed"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

// Options
var (
	tmpl     = flag.String("tmpl", "init", "code template")
	pkg      = flag.String("pkg", "main", "package for generated code")
	file     = flag.String("file", "licenses.go", "filename for generated code")
	variable = flag.String("var", "Licenses", "variable name")
	credits  = flag.Bool("credits", false, "show open source credits")
	help     = flag.Bool("help", false, "show help")
)

// Non-options
const comment = "Code generated by licensepack; DO NOT EDIT."

//go:generate go run github.com/paulhammond/licensepack .
var Licenses string

//go:embed tmpl/*.tmpl
var tmplFS embed.FS

func mustFS(fs fs.FS, err error) fs.FS {
	if err != nil {
		panic(err)
	}
	return fs
}

var templates = template.Must(template.ParseFS(mustFS(fs.Sub(tmplFS, "tmpl")), "*"))

func main() {
	flag.Usage = func() {
		fmt.Fprintln(flag.CommandLine.Output(), "Usage: licensepack [options] [pkg]")
		fmt.Fprintln(flag.CommandLine.Output())
		fmt.Fprintln(flag.CommandLine.Output(), "Options:")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *credits {
		fmt.Println("This software builds on many open source projects. We're grateful to the")
		fmt.Println("developers of the following projects for their hard work.")
		fmt.Println("")
		fmt.Println(Licenses)
		os.Exit(0)
	}

	if *help || len(flag.Args()) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	fmt.Printf("licensepack: generating %s\n", *file)

	var buf bytes.Buffer

	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedDeps | packages.NeedImports | packages.NeedName | packages.NeedModule}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error loading packages: %v\n", err)
		os.Exit(1)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	paths := map[string]string{
		"golang.org/pkg": build.Default.GOROOT,
	}
	mainPath := ""
	packages.Visit(pkgs, func(p *packages.Package) bool {
		// here we assume that the only packages that don't have a module are in
		// the standard library. Maybe that's not true?
		if p.Module != nil {
			paths[p.Module.Path] = p.Module.Dir

			if p.Module.Main {
				mainPath = p.Module.Path
			}
		}
		return true
	}, nil)

	i := 0
	for k, v := range paths {
		isMain := (k == mainPath)
		files, err := os.ReadDir(v)
		if err != nil {
			log.Fatal(err)
		}

		fmt.Println(k, v)
		found := false
		for _, file := range files {
			re := regexp.MustCompile(`(?i)(licen(c|s)e|notice|copying)`)
			if re.MatchString(file.Name()) {
				path := filepath.Join(v, file.Name())

				stat, err := os.Stat(path)
				if err != nil {
					log.Fatal(err)
				}
				if stat.IsDir() {
					continue
				}

				contents, err := os.ReadFile(path)
				if err != nil {
					log.Fatal(err)
				}

				if strings.Contains(string(contents), comment) {
					continue
				}

				if !found {
					fmt.Fprintf(&buf, "## %s\n\n", k)
					found = true
				}
				fmt.Fprintf(&buf, "%s:\n\n", file.Name())
				fmt.Fprintf(&buf, "%s\n\n", contents)
			}
		}
		if found == false && !isMain {
			fmt.Printf("Error: could not find license for %s", k)
			os.Exit(1)
		}
		i++
		fmt.Fprint(&buf, "\n\n")
	}

	var src bytes.Buffer
	_, err = src.Write([]byte("// " + comment + "\n"))
	if err != nil {
		log.Fatal(err)
	}
	err = templates.ExecuteTemplate(&src, *tmpl+".tmpl", struct {
		String string
		Pkg    string
		Var    string
	}{
		String: buf.String(),
		Pkg:    *pkg,
		Var:    *variable,
	})
	if err != nil {
		log.Fatal(err)
	}

	formatted, err := format.Source(src.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile(*file, formatted, 0666)
	if err != nil {
		log.Fatal(err)
	}
}
