package main

import (
	"bytes"
	"crypto/sha256"
	"embed"
	"errors"
	"flag"
	"fmt"
	"go/build"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/mitchellh/go-wordwrap"
	"golang.org/x/tools/go/packages"
)

const comment = "Code generated by licensepack; DO NOT EDIT."

//go:generate go run github.com/paulhammond/licensepack .
//go:embed credits.txt
var credits string

//go:embed tmpl/*.tmpl
var tmplFS embed.FS

func parseTemplate(name string) (*template.Template, error) {
	t := template.New("")
	fs2, err := fs.Sub(tmplFS, "tmpl")
	if err != nil {
		panic(err)
	}

	if regexp.MustCompile(`^[a-z\-]+$`).MatchString(name) {
		name = name + ".tmpl"
		_, err = t.ParseFS(fs2, name)
	} else {
		_, err = t.ParseFiles(name)
	}
	if err != nil {
		return nil, err
	}
	t = t.Lookup(filepath.Base(name))
	if t == nil {
		return nil, errors.New("could not find template")
	}
	return t, nil
}

func main() {
	var (
		tmpl        = flag.String("tmpl", "default", "template")
		file        = flag.String("file", "credits.txt", "filename for generated code (- for stdout)")
		notrim      = flag.Bool("notrim", false, "do not trim whitespace from output")
		wrap        = flag.Uint("wrap", 120, "width to wrap text at (0 to disable)")
		showCredits = flag.Bool("credits", false, "show open source credits")
		help        = flag.Bool("help", false, "show help")
	)

	flag.Usage = func() {
		fmt.Fprintln(flag.CommandLine.Output(), "Usage: licensepack [options] [pkg]")
		fmt.Fprintln(flag.CommandLine.Output())
		fmt.Fprintln(flag.CommandLine.Output(), "Options:")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showCredits {
		fmt.Println("This software builds on many open source projects. We're grateful to the")
		fmt.Println("developers of the following projects for their hard work.")
		fmt.Println("")
		fmt.Println(credits)
		os.Exit(0)
	}

	if *help || len(flag.Args()) == 0 {
		flag.Usage()
		os.Exit(0)
	}

	cfg := &packages.Config{Mode: packages.NeedFiles | packages.NeedDeps | packages.NeedImports | packages.NeedName | packages.NeedModule}
	pkgs, err := packages.Load(cfg, flag.Args()...)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error loading packages: %v\n", err)
		os.Exit(1)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	paths := map[string]string{
		"golang.org/pkg": build.Default.GOROOT,
	}
	mainPath := ""
	packages.Visit(pkgs, func(p *packages.Package) bool {
		// here we assume that the only packages that don't have a module are in
		// the standard library. Maybe that's not true?
		if p.Module != nil {
			paths[p.Module.Path] = p.Module.Dir

			if p.Module.Main {
				mainPath = p.Module.Path
			}
		}
		return true
	}, nil)

	modules := make([]Module, 0, len(paths))
	for k, v := range paths {
		isMain := (k == mainPath)
		files := []File{}
		dirEntries, err := os.ReadDir(v)
		if err != nil {
			log.Fatal(err)
		}

		for _, entry := range dirEntries {
			re := regexp.MustCompile(`(?i)(licen(c|s)e|notice|copying)`)
			if re.MatchString(entry.Name()) {
				path := filepath.Join(v, entry.Name())
				if filepath.Ext(path) == ".go" {
					continue
				}

				stat, err := os.Stat(path)
				if err != nil {
					log.Fatal(err)
				}
				if stat.IsDir() {
					continue
				}

				contents, err := os.ReadFile(path)
				if err != nil {
					log.Fatal(err)
				}

				if strings.Contains(string(contents), comment) {
					continue
				}

				trimmed := strings.TrimSpace(string(contents))

				files = append(files, File{Path: entry.Name(), Contents: trimmed})
			}
		}
		if len(files) == 0 && !isMain {
			fmt.Printf("Error: could not find license for %s", k)
			os.Exit(1)
		}
		sort.Slice(files, func(i, j int) bool {
			return files[i].Path < files[j].Path
		})

		modules = append(modules, Module{
			Name:     k,
			Licenses: files,
		})
	}

	sort.Slice(modules, func(i, j int) bool {
		if modules[j].Name == mainPath {
			return false
		}
		return (modules[i].Name == mainPath) || modules[i].Name < modules[j].Name
	})

	set := ModuleSet{Modules: modules}

	var src bytes.Buffer

	t, err := parseTemplate(*tmpl)
	if err != nil {
		log.Fatal(err)
	}

	err = t.Execute(&src, set)
	if err != nil {
		log.Fatal(err)
	}

	output := src.String()
	if !*notrim {
		output = strings.TrimSpace(output) + "\n"
	}
	if *wrap != 0 {
		output = wordwrap.WrapString(output, *wrap)
	}

	if *file == "-" {
		_, err = fmt.Print(output)
	} else {
		err = os.WriteFile(*file, []byte(output), 0o666)
	}

	if err != nil {
		log.Fatal(err)
	}
}

// A ModuleSet is a set of Modules
type ModuleSet struct {
	Modules []Module
}

// FileGroups returns groups of individual license files. All files in a group
// have the same content.
func (s ModuleSet) FileGroups() []*Group {
	groups := []*Group{}
	lookup := map[string]*Group{}
	for _, m := range s.Modules {
		for _, f := range m.Licenses {
			h := f.hash()
			name := m.Name + " " + f.Path
			if found, ok := lookup[h]; ok {
				found.Names = append(found.Names, name)
			} else {
				s := &Group{
					Names:    []string{name},
					Licenses: []File{f},
				}
				lookup[h] = s
				groups = append(groups, s)
			}
		}
	}
	return groups
}

// ModuleGroups returns groups of Modules. All modules in a group have identical
// license file paths and contents.
func (s ModuleSet) ModuleGroups() []*Group {
	moduleGroups := []*Group{}
	moduleMap := map[string]*Group{}
	for _, m := range s.Modules {
		h := m.hash()
		if found, ok := moduleMap[h]; ok {
			found.Names = append(found.Names, m.Name)
		} else {
			s := &Group{
				Names:    []string{m.Name},
				Licenses: m.Licenses,
			}
			moduleMap[h] = s
			moduleGroups = append(moduleGroups, s)
		}
	}
	return moduleGroups
}

// A Group is a grouping of identical license files.
type Group struct {
	Names    []string
	Licenses []File
}

// A Module represents a Go module. Some modules have more than one license file.
type Module struct {
	Name     string
	Licenses []File
}

func (m Module) hash() string {
	h := sha256.New()
	for _, f := range m.Licenses {
		fmt.Fprintln(h, f.Path)
		fmt.Fprintln(h, f.Contents)
	}
	return fmt.Sprintf("%x", h.Sum(nil))
}

// A File represents an individual license file for a Go module.
type File struct {
	Path     string
	Contents string
}

func (f File) hash() string {
	h := sha256.New()
	fmt.Fprintln(h, f.Contents)
	return fmt.Sprintf("%x", h.Sum(nil))
}
